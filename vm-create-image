#!/bin/bash
# Create ext4 image out of file tree
# Copyright (c) 2022 Vitaly Chikunov <vt@altlinux.org>
# Inspired by the work of Leonid Krivoshein <klark@altlinux.org> on usermode-fs-tools.

set -efu
export DEBUGFS_PAGER=__none__
export LC_ALL=C
TMP=$(mktemp -d)
# shellcheck disable=SC2064
trap "rm -rf '$TMP'" 0

show_usage()
{
	echo "Usage: $0 [OPTIONS...] IMAGE"
	echo "Create ext4 IMAGE from rootfs (or DIR)."
	echo
	echo "  --dir=         Dir to copy into image (default: /)"
	echo "  --exclude=     Mask to exclude from dir (default: /tmp/*)"
	echo "  --fs=          Specify fs type: ext4 (default), ext3, ext2."
	echo "  --qcow2        After creation convert IMAGE to qcow2 format"
	echo "  --realuids     Set UID/GID to real values instead of root:root."
	echo "                 Default when libfakeroot is loaded (as is under rooter)."
	echo "  --size=        Size of image (Kb) (default: double of du of DIR)"
	echo "  --special      Copy special files (block, character devices, pipes)"
	echo "  --volume=      EXT4 volume name (default: basename of IMAGE)"
	echo "  -v, --verbose  Increase verbosity"
	echo
	echo "Informational options:"
	echo "  --cat=FILE     Cat FILE from IMAGE"
	echo "  --cp A B       Copy file/dir 'A' from the image into file/dir 'B'"
	echo "  --ls=DIR       Do not create an image but 'ls -l DIR' in it."
	echo "  --stat=FILE    Run stat on FILE in IMAGE"
	exit "$@"
}

error()
{
	echo >&2 "$(basename "$0"): $*"
}

fatal()
{
	error "$@"
	echo
	show_usage 1
}

exclude=()
dir="/"
size=
image=
declare -i verbose=0
fs_type=ext4
unset ls_path cat_path stat_path qcow2 copy_mode

# Seems to be true under rooter and scriptlets.
[[ "${LD_PRELOAD-}" =~ libfakeroot.so ]] && realuids=y || realuids=n

for opt; do
	shift
	arg=${opt##*=}
	case $opt in
		--dir=*)        dir=$arg ;;
		--exclude=*)    exclude+=( "$arg" ) ;;
		--volume=*)     volume=$arg ;;
		--size=*)       size=$arg ;;
		--fs=*)         fs_type=$arg ;;
		--ls=*)         ls_path=$arg ;;
		--cat=*)        cat_path=$arg ;;
		--cp)           copy_mode=y ;;
		--stat=*)       stat_path=$arg ;;
		--qcow2)        qcow2=y ;;
		--special)      special=y ;;
		--realuids)     realuids=y ;;
		--no-realuids)  unset realuids ;;
		-v | --verbose) verbose+=1 ;;
		-h | --help)    show_usage ;;
		-*)             fatal "Unknown option $opt" ;;
		*)              set -- "$@" "$opt" ;;
	esac
done
[ -n "${1-}" ] || fatal "Specifying IMAGE is required."
image="$1"; shift

[ $verbose -gt 0 ] && SETX="set -x" || SETX=:
[ $verbose -gt 0 ] && VERBOSE=-v || VERBOSE=
[ $verbose -gt 1 ] && NULL="1" || NULL=/dev/null

if [ -v ls_path ]; then
	/sbin/debugfs "$image" -R "ls -l $ls_path"
	exit
elif [ -v cat_path ]; then
	/sbin/debugfs "$image" -R "cat $cat_path" 2>/dev/null
	exit
elif [ -v stat_path ]; then
	/sbin/debugfs "$image" -R "stat $stat_path"
	exit
elif [ -v copy_mode ]; then
	[ $# -gt 2 ] && fatal "Too much arguments for cp mode"
	info=$(/sbin/debugfs "$image" -R "stat $1" 2>&1 | head -2)
	if [[ "$info" =~ File.not.found ]]; then
		echo "$info" >&2
		exit 1
	elif [[ "$info" =~ Type:.directory ]]; then
		mkdir -p "$2"
		($SETX; /sbin/debugfs "$image" -R "rdump \"$1\" \"$2\"")
	else
		($SETX; /sbin/debugfs "$image" -R "dump \"$1\" \"$2\"")
	fi
	exit
fi
[ $# -gt 0 ] && fatal "Unknown argument(s): $*"

if [ "$dir" = '/' ] && [ -z "${exclude-}" ]; then
	# /tmp is on the same tmpfs so -xdev will not work.
	exclude=( "/tmp/*" )
fi
# shellcheck disable=SC2068
total=$(set -f; du -scx ${exclude[@]/#/--exclude } "$dir" 2>/dev/null | tail -1)
total=${total%%[[:space:]]*}
[ $verbose -gt 0 ] && echo >&2 "Source directory='$dir' size=$total kb"
unit=1024
shopt -s nocasematch
case "$size" in
	*B) unit=1/$unit ;;
	*K | *[0-9]) unit=1 ;;
	*M) unit=$((unit*unit)) ;;
	*G) unit=$((unit*unit*unit)) ;;
	*T) unit=$((unit*unit*unit*unit)) ;;
	*[A-Z]) fatal "Unknown unit size: $size" ;;
esac
shopt -u nocasematch
sz=${size%[BKMGTbkmgt]}
case "$sz" in
	+*)   size=$((total + ${sz#+} * $unit)) ;;
	*%)   size=$((total * ${sz%'%'} / 100)) ;;
	'*'*) size=$((total * ${sz#'*'})) ;;
	'')   size=$((total * 3)) ;;
	*)    size=$((sz * $unit)) ;;
esac
[ "$size" -lt 10000 ] && size="10M"
unset unit sz
if [ "${realuids-}" = 'n' ]; then
	unset realuids
	error "libfakeroot is not detected so realuids mode if off, use --realuids to enable."
fi

[ $verbose -gt 0 ] && echo >&2 "Creating ${fs_type:-ext4} image '$image' size=$size" \
	${realuids+(realuids)} ${special+(special)} ${volume+volume=$volume}
rm -f "$image"
[ -v volume ] || volume="$(basename "$image")"
# mke2fs does not create ext4 by default (even if `-t ext4` is passed),
# requiring appropriate additional options (like enabling journal, etc),
# but mkfs.ext4 does the right thing.
($SETX; /sbin/mkfs.$fs_type ${VERBOSE:--q} -F -L "$volume" -m0 -- "$image" "$size")

set_metadata()
{
	local t=$1 md=$2 us=$3 gr=$4 ts=$5 f=$6
	local ty

	if [ -v realuids ]; then
		[ "$us" -eq 0 ] || printf 'sif "%s" uid %s\n' "$f" "$us"
		[ "$gr" -eq 0 ] || printf 'sif "%s" gid %s\n' "$f" "$gr"
	fi
	printf 'sif "%s" mtime @%s\n' "$f" "${ts%.*}"
	case "$t" in
		s) ty=014 ;;
		l) ty=012 ;;
		f) ty=010 ;;
		b) ty=006 ;;
		d) ty=004 ;;
		c) ty=002 ;;
		p) ty=001 ;;
	esac
	[ "$ty" = "010" ] || printf 'sif "%s" mode %03o%04o\n' "$f" "$ty" "0$md"
}

>"$TMP/hardlinks"
declare -i hl
( set -f
  $SETX
  # shellcheck disable=SC2068
  find "$dir" -xdev \
	 ${exclude[@]/#/-not -path } \
	 -not -samefile "$image" \
	 -not -samefile "$dir" \
	 -printf '%D:%i %n %y %m %U %G %T@ %P\n'
) | {
printf 'lcd "%s"\n' "$dir"
while read -r di hl t md us gr ts f; do
	f="${f//[[:cntrl:]]/?}"
	case "$t" in
	   f)	if [ "$hl" -gt 1 ]; then
			echo "$di $hl $t $md $us $gr $ts $f" >>"$TMP/hardlinks"
			continue
		fi
		printf 'write "%s" "%s"\n' "$f" "$f"
		;;
	   d)	printf 'mkdir "%s"\n' "$f"
		;;
	   l)	printf 'symlink "%s" "%s"\n' "$f" "$(readlink -n -- "$dir/$f")"
		;;
	   *)	if [ -v special ]; then
			case "$t" in
				c | b) minmaj="$(stat -c '%Hr %Lr' -- "$dir/$f")" ;;
				s) continue ;; # No support in debugfs(8).
				*) continue ;;
			esac
			printf 'cd "%s"\nmknod "%s" %s %s\ncd /\n' \
				"$(dirname "$f")" \
				"$(basename "$f")" \
				"$t" \
				"$minmaj"
		else
			continue
		fi
		;;
	esac
	set_metadata "$t" "$md" "$us" "$gr" "$ts" "$f"
done
sort "$TMP/hardlinks" \
| while read -r di hl t md us gr ts f; do
	if [ "$di" != "${pdi-}" ]; then
		printf 'write "%s" "%s"\n' "$f" "$f"
		set_metadata "$t" "$md" "$us" "$gr" "$ts" "$f"
		printf 'sif "%s" links_count %d\n' "$f" "$hl"
		pdi="$di"
		pf="$f"
	else
		printf 'ln "%s" "%s"\n' "$pf" "$f"
	fi
done
} | ($SETX; /sbin/debugfs -f- -w "$image") >&"$NULL"
($SETX; /sbin/e2fsck $VERBOSE -p "$image")
if [ -v qcow2 ]; then
	mv -f "$image" "$image.raw"
	($SETX; qemu-img convert "$image.raw" "$image" -O qcow2)
	rm "$image.raw"
fi
